# Security Model

## Threat model

agent-to-go gives your phone browser full terminal access to your computer. The security boundary is your Tailnet: **all devices on the Tailnet are fully trusted**. There is no authentication beyond Tailnet membership.

This means:
- This is designed for a single-user Tailnet
- Don't use this on a shared Tailnet where you don't trust every device
- **Run on a dedicated coding VM** rather than your main machine. This limits the blast radius — if anything goes wrong, the attacker gets a VM with code on it, not your personal machine with credentials, keys, and personal data.
- If your Tailscale key is compromised, your terminals are exposed

The CSRF, Origin, and TLS protections exist solely to defend against browser-based attacks from the public internet (malicious websites, DNS rebinding, cross-origin requests). They do not protect against a malicious device on the Tailnet.

## Architecture

```
Phone (browser)
  |
  | HTTPS over WireGuard (Tailscale)
  |
  v
agent-to-go :443 (tsnet — embedded Tailscale node, automatic TLS)
  |
  |-- GET  /                 Index page (lists sessions)
  |-- POST /connect/{s}      Start ttyd, redirect to /terminal/{s}/
  |-- GET  /terminal/{s}/*   Reverse proxy to ttyd (HTTP + WebSocket)
  |-- POST /spawn            Create new tmux session + ttyd
  |-- POST /spawn-project    Same handler as /spawn
  |-- POST /kill/{s}         Kill a tmux session
  |
  | reverse proxy
  |
  v
ttyd :7700+ (one per active session, bound to 127.0.0.1 only)
  |
  | WebSocket
  |
  v
tmux session (persistent terminal)
```

## Security layers

All security primitives are in `server/security.go`. The CSRF middleware is wired in `server/main.go`.

### 1. Tailscale network (primary boundary)

tsnet embeds a Tailscale node directly in the Go process. The server is only reachable from the Tailnet — there is no public IP, no port forwarding, no firewall rules to maintain. If Tailscale is unavailable, the server refuses to start.

### 2. TLS (transport encryption)

tsnet provides automatic Let's Encrypt TLS certificates for `*.ts.net` domains via `ListenTLS`. All traffic is encrypted twice: WireGuard (Tailscale tunnel) and TLS (HTTPS). This ensures encryption even within the Tailnet and enables gorilla/csrf's Referer checking (which requires HTTPS).

### 3. CSRF protection (gorilla/csrf)

All state-changing endpoints (connect, spawn, kill) require POST with a valid CSRF token. gorilla/csrf implements:

- **Double-submit cookie pattern**: a random token in a cookie + a matching token in the form body. The server validates they match via HMAC.
- **Per-request token rotation** with BREACH mitigation (masked tokens).
- **Referer checking**: on HTTPS requests, gorilla/csrf validates the Referer header matches the request host. Cross-origin POSTs are rejected.
- **SameSite=Strict cookies**: the CSRF cookie is never sent on cross-origin requests in modern browsers.
- **Persistent 32-byte HMAC key**: stored at `~/.config/agent-to-go/csrf-key` with `0600` permissions. Generated from `crypto/rand`.

### 4. POST enforcement

All mutating endpoints (`/connect/`, `/spawn`, `/kill/`) reject non-POST methods with 405. This prevents GET-based attacks (img tags, link prefetch, etc.) from triggering side effects. Implemented in `requirePOST()` in `security.go`.

### 5. WebSocket Origin validation

WebSocket upgrades on `/terminal/{session}/*` check the `Origin` header against the request's `Host` header. Browsers send Origin on WebSocket handshakes and it cannot be forged by cross-origin pages. This blocks cross-site WebSocket CSRF. Implemented in `checkWebSocketOrigin()` in `security.go`.

### 6. Session name validation

Session names in `/connect/` and `/kill/` are validated against the actual list of tmux sessions. Only exact matches are accepted. Since session names are passed to `exec.Command` (not a shell), command injection via session names is not possible even without this validation — but the validation provides defense in depth.

### 7. Reverse proxy isolation

ttyd instances bind to `127.0.0.1` and are not directly reachable from the network. All browser traffic goes through the `/terminal/{session}/` reverse proxy. This means ttyd is never exposed to cross-origin attacks directly.

`/terminal/{session}/` is accessible via GET (no CSRF required) because the browser needs to load ttyd's HTML, JavaScript, and WebSocket. However, a session only appears in the proxy's routing table after a CSRF-protected POST to `/connect/`.

### 8. Argument injection prevention

All `tmux` and `ttyd` commands use `exec.Command` (no shell invocation). The `tmux new-session` command uses `--` before the command argument to prevent flag injection. Session names passed to `-t` flags are validated against the real tmux session list first. Since session names are generated by `generateSessionName` (which always starts with an alphanumeric command name), they cannot start with `-`.

## Known limitations and accepted risks

### Tailnet access = full access

There is no authentication within the Tailnet. A script running on any Tailnet device can access any endpoint. This is the intended security model — Tailscale is the auth boundary.

### Any command can be spawned

There are no command or directory restrictions. Any command can be run in any directory via the spawn endpoint. The security boundary is the Tailnet — if you can reach the server, you have full terminal access anyway.

### tmux runs commands through sh -c

When `spawnSession` calls `tmux new-session ... -- cmd`, tmux passes `cmd` through `sh -c`. Since the server is only accessible from the Tailnet, this is equivalent to having shell access (which the terminal already provides).

### Catch-all route

`mux.HandleFunc("/", handleIndex)` makes the index page a catch-all — any unmatched path returns the full index page (no 404 responses). This has no security impact since the index page is read-only.

### Cleanup goroutine holds mutex during Kill+Wait

The orphaned ttyd cleanup goroutine calls `Process.Kill()` then `cmd.Wait()` while holding `portMutex`. Since `Kill` sends SIGKILL, `Wait` returns promptly. If it didn't (kernel bug), it would block all `startTtyd` calls.

### Readiness poll holds mutex

The `startTtyd` readiness loop (polling TCP for up to 2 seconds) runs while holding `portMutex`. This blocks other `startTtyd` calls during the poll — acceptable for a single-user service.

## Test coverage

The test suite includes:

- **CSRF integration tests** (`csrf_test.go`): token required on all POST endpoints, wrong token rejected, valid token accepted
- **Attack simulations** (`csrf_test.go`): cross-site reverse shell, hidden form CSRF, img tag GET, session kill DoS
- **Handler tests** (`handlers_test.go`): POST-only enforcement, invalid session rejection
- **Tmux tests** (`tmux_test.go`): session name generation, nonexistent directory rejection
- **Proxy tests** (`ttyd_test.go`): empty session, unknown session, known session proxies correctly
